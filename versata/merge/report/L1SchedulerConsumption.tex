\subsubsection{Scheduler for consumption prediction requests}
\paragraph{Architectural drivers}
The main purpose of this component is making sure that new requests for
	consumption prediction can be saved and scheduled while other computations
	are still running. When a new computation can be made, the scheduler will
	acquire the required data from the data storage and hand this information
	to the computation of consumption prediction component.
\begin{itemize}
	\item \textbf{UC14': Request consumption prediction}
\end{itemize}


\paragraph{Tactics}
\begin{itemize}
	 \item{Performance}
	 \begin{itemize}
		\item{Scheduling Policy} \\
		To ensure that incoming consumption predictions are not lost and handed
			to the computation of consumption prediction component in FIFO order.
	 \end{itemize}
\end{itemize}

\paragraph{Architectural Patterns}
\begin{itemize}
	\item Proxy \\
	To increase the modifiability of the internal working of this component we chose
		to use the explicit interface pattern. The interface that we see outside the
		component will simply delegate it's methods to an internal component.
	\item Active Object \\
	The active object pattern allows us to insert new consumption prediction requests
		in a buffer which in its turn can be emptied by a scheduler. The scheduler can
		decide which requests need to be treated first. At the moment, this happens in
		FIFO order.
\end{itemize}
\inclimg{0.40}{0}{L2SchedulerPrediction}{The Scheduler for Consumption Prediction Requests after decomposition}

\paragraph{Verification and refinement of drivers}
All the required parts of UC14' we needed to address in this component have been addressed.
No further delegation is needed.


% •	How do we handle functionality (Use Cases) which is not handled in combination with a QAS?
% Because we only provided 9 QAS, it can indeed be the case that some functionality is not related to a QAS and therefore is not handled in ADD. You can add components providing this functionality when you notice this, at the end of an ADD iteration or at the end of your final iteration. Because these components have no quality requirements, the result should be the same.

